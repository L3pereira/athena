use athena_core::{
    entities::{MarginAccount, Order, Position, PositionSide, Trade},
    instruments::InstrumentId,
};
use rust_decimal::Decimal;
use std::collections::HashMap;
use thiserror::Error;
use uuid::Uuid;

/// Risk management errors
#[derive(Debug, Error)]
pub enum RiskError {
    #[error("Insufficient margin: required {required}, available {available}")]
    InsufficientMargin {
        required: Decimal,
        available: Decimal,
    },

    #[error("Position not found: {0}")]
    PositionNotFound(String),

    #[error("Account not found: {0}")]
    AccountNotFound(Uuid),

    #[error("Account frozen: {0}")]
    AccountFrozen(Uuid),

    #[error("Order rejected: {0}")]
    OrderRejected(String),

    #[error("Liquidation required for position: {0}")]
    LiquidationRequired(String),

    #[error("Maximum position size exceeded: {0}")]
    MaxPositionExceeded(String),

    #[error("Risk limit exceeded: {0}")]
    RiskLimitExceeded(String),
}

pub type RiskResult<T> = Result<T, RiskError>;

/// Risk check result for pre-trade validation
#[derive(Debug, Clone)]
pub struct RiskCheckResult {
    /// Whether the order passes risk checks
    pub approved: bool,

    /// Required margin for the order
    pub required_margin: Decimal,

    /// Available margin after the order
    pub available_margin_after: Decimal,

    /// New margin ratio after the order
    pub margin_ratio_after: Decimal,

    /// Any warnings (order may still be approved)
    pub warnings: Vec<String>,

    /// Rejection reason if not approved
    pub rejection_reason: Option<String>,
}

impl RiskCheckResult {
    pub fn approved(
        required_margin: Decimal,
        available_after: Decimal,
        ratio_after: Decimal,
    ) -> Self {
        Self {
            approved: true,
            required_margin,
            available_margin_after: available_after,
            margin_ratio_after: ratio_after,
            warnings: Vec::new(),
            rejection_reason: None,
        }
    }

    pub fn rejected(reason: String) -> Self {
        Self {
            approved: false,
            required_margin: Decimal::ZERO,
            available_margin_after: Decimal::ZERO,
            margin_ratio_after: Decimal::ZERO,
            warnings: Vec::new(),
            rejection_reason: Some(reason),
        }
    }

    pub fn with_warning(mut self, warning: String) -> Self {
        self.warnings.push(warning);
        self
    }
}

/// Liquidation order generated by the risk manager
#[derive(Debug, Clone)]
pub struct LiquidationOrder {
    /// Account being liquidated
    pub account_id: Uuid,

    /// Position being liquidated
    pub position_id: Uuid,

    /// Instrument
    pub instrument_id: InstrumentId,

    /// Side to close (opposite of position side)
    pub close_side: PositionSide,

    /// Quantity to liquidate
    pub quantity: Decimal,

    /// Current mark price
    pub mark_price: Decimal,

    /// Liquidation price that triggered this
    pub liquidation_price: Decimal,

    /// Reason for liquidation
    pub reason: String,
}

/// Port for risk management operations
pub trait RiskManager: Send + Sync {
    /// Validate an order before execution (pre-trade risk check)
    fn validate_order(&self, account: &MarginAccount, order: &Order)
    -> RiskResult<RiskCheckResult>;

    /// Calculate required margin for an order
    fn calculate_required_margin(
        &self,
        order: &Order,
        current_position: Option<&Position>,
    ) -> Decimal;

    /// Process a trade and update positions
    fn process_trade(&self, account: &mut MarginAccount, trade: &Trade) -> RiskResult<()>;

    /// Update mark prices and check for liquidations
    fn update_mark_prices(
        &self,
        account: &mut MarginAccount,
        prices: &HashMap<InstrumentId, Decimal>,
    ) -> Vec<LiquidationOrder>;

    /// Check if a position should be liquidated
    fn check_liquidation(&self, position: &Position) -> bool;

    /// Generate liquidation orders for positions that need to be closed
    fn generate_liquidation_orders(&self, account: &MarginAccount) -> Vec<LiquidationOrder>;

    /// Calculate the effective leverage for an account
    fn calculate_leverage(&self, account: &MarginAccount) -> Decimal;

    /// Get maximum allowed position size for an instrument
    fn max_position_size(
        &self,
        account: &MarginAccount,
        instrument_id: &InstrumentId,
        side: PositionSide,
        price: Decimal,
    ) -> Decimal;
}

/// Configuration for risk parameters
#[derive(Debug, Clone)]
pub struct RiskConfig {
    /// Initial margin rate (e.g., 0.10 for 10x leverage)
    pub initial_margin_rate: Decimal,

    /// Maintenance margin rate (e.g., 0.05)
    pub maintenance_margin_rate: Decimal,

    /// Maximum leverage allowed
    pub max_leverage: Decimal,

    /// Maximum position size per instrument (in base currency)
    pub max_position_size: Option<Decimal>,

    /// Maximum total exposure across all positions
    pub max_total_exposure: Option<Decimal>,

    /// Margin call threshold (% of maintenance margin)
    pub margin_call_threshold: Decimal,

    /// Auto-deleveraging enabled
    pub auto_deleverage: bool,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            initial_margin_rate: Decimal::new(10, 2), // 10% = 10x leverage
            maintenance_margin_rate: Decimal::new(5, 2), // 5%
            max_leverage: Decimal::new(10, 0),        // 10x
            max_position_size: None,
            max_total_exposure: None,
            margin_call_threshold: Decimal::new(80, 2), // 80%
            auto_deleverage: true,
        }
    }
}

impl RiskConfig {
    /// Create config for a specific leverage level
    pub fn with_leverage(leverage: u32) -> Self {
        let initial_margin_rate = Decimal::ONE / Decimal::from(leverage);
        let maintenance_margin_rate = initial_margin_rate / Decimal::new(2, 0);

        Self {
            initial_margin_rate,
            maintenance_margin_rate,
            max_leverage: Decimal::from(leverage),
            ..Default::default()
        }
    }
}
